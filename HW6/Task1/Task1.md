# Задача 6

> Все расчеты находятся в файле [Task1.ipynb](/HW6/Task1/Task1.ipynb)

## Численное интегрирование методом Симпсона с уточнением по Эйткену

### Постановка задачи

Вычисляется значение интеграла:

$$ I = \int_{0}^{\pi} \left| \cos(\sin(x)) - \frac{3}{4} \right| dx $$

Для вычислений будет использовать **составной метод Симпсона** с автоматическим выбором шага (по правилу Рунге) и последующим уточнением результата с помощью **процесса Эйткена**

В качестве точного значения будем использовать значение, вычисленное библиотекой `scipy.integrate.quad` с высокой точностью:  
**$$I_{exact} \approx 0.460043630500$$**

#### Составной метод Симпсона (`simpson_method`)

Функция реализует классическую формулу составного метода Симпсона (метода парабол). Отрезок $[a, b]$ разбивается на $n$ частей с шагом $h = \frac{b-a}{n}$.

**Алгоритм работы функции:**
1.  Вычисляется шаг `h`.
2.  Суммируются значения функции на краях отрезка (`integral`).
3.  В цикле суммируются значения во внутренних узлах:
    *   Для **нечетных** индексов ($x_1, x_3, \dots$) используется коэффициент **4**.
    *   Для **четных** индексов ($x_2, x_4, \dots$) используется коэффициент **2**.
4.  Результат умножается на $h/3$.

$$ I \approx \frac{h}{3} \left[ f(a) + f(b) + 4 \sum_{i \text{ нечет}} f(x_i) + 2 \sum_{i \text{ чет}} f(x_i) \right] $$

**Код:**
```python
def simpson_method(f, a, b, n):
    h = (b - a) / n
    integral = f(a) + f(b)
    
    sum_odd = 0
    for i in range(1, n, 2):      # Нечетные узлы
        sum_odd += f(a + i * h)
        
    sum_even = 0
    for i in range(2, n, 2):      # Четные узлы
        sum_even += f(a + i * h)
        
    integral = (h / 3) * (integral + 4 * sum_odd + 2 * sum_even)
    return integral
```

Теоретический порядок точности метода для гладких функций — $O(h^4)$. Однако, так как подынтегральная функция содержит модуль (является негладкой, имеет разрывы производной), порядок сходимости может снижаться.

#### Процесс Эйткена (`aitken_process`)

Этот метод используется для экстраполяции последовательности приближенных значений к точному решению. Он позволяет повысить точность результата, используя информацию о скорости сходимости метода.

В функцию передаются три значения интеграла, вычисленные с разными шагами:
*   `I_h`: Значение интеграла с текущим шагом $h$ (самое точное, $N$ разбиений).
*   `I_2h`: Значение с шагом $2h$ ($N/2$ разбиений).
*   `I_4h`: Значение с шагом $4h$ ($N/4$ разбиений).

**Используемая формула:**

$$\tilde I = I_h - \frac{(I_{2h} - I_h)^2}{I_{4h} - 2I_{2h} + I_h} $$

**Код:**
```python
def aitken_process(I_h, I_2h, I_4h):
    numerator = (I_2h - I_h) ** 2
    denominator = I_4h - 2 * I_2h + I_h
    return I_h - (numerator / denominator)
```

#### Эффективный порядок сходимости

$$
\begin{cases}
I_h = I + ch^p, \\
I_{2h} = I + c(2h)^p = I + 2^p \cdot c h^p
\end{cases}
$$

Тогда:

$$ p_{eff} \approx \log_2 \left( \frac{|I_{2h} - I_{exact}|}{|I_{h} - I_{exact}|} \right) $$

Будем вычислять на каждом шаге.

### Результаты вычислений

Ниже приведена таблица зависимости ошибки от количества разбиений $N$.

| N | Значение интеграла (Симпсон) | Ошибка Симпсона | $p_{eff}$ | Ошибка (Эйткен) |
|---|---|---|---|---|
| 4 | 0.262153384 | 1.98e-01 | - | - |
| 8 | 0.465985770 | 5.94e-03 | 5.06 | - |
| 16 | 0.462329552 | 2.29e-03 | 1.38 | 2.35e-03 |
| 32 | 0.460930830 | 8.87e-04 | 1.37 | 2.06e-05 |
| 64 | 0.460256766 | 2.13e-04 | 2.06 | 4.14e-04 |
| 128 | 0.459921291 | 1.22e-04 | 0.80 | 4.55e-04 |
| 256 | 0.460055629 | 1.20e-05 | **3.35** | 2.64e-05 |
| 512 | 0.460047434 | 3.80e-06 | 1.66 | 4.28e-06 |
| 1024 | 0.460043338 | 2.93e-07 | **3.70** | 4.39e-06 |
| 2048 | 0.460043748 | 1.17e-07 | 1.32 | **8.01e-08** |

### Анализ результатов

1.  **Порядок сходимости:**
    Как видно из столбца `p_eff`, эффективный порядок сходимости ведет себя нестабильно (колеблется от 0.8 до 5.06). Это подтверждает гипотезу о влиянии модуля в подынтегральной функции. В точках излома функции (где $\cos(\sin(x)) = 0.75$) гладкость нарушается, и классическая оценка $O(h^4)$ перестает работать. В среднем порядок сходимости ближе ко второму-третьему, чем к четвертому.

2.  **Эффективность Эйткена:**
    Метод Эйткена показывает хорошие результаты на некоторых "удачных" шагах (например, при $N=32$ ошибка резко падает до $2.06 \cdot 10^{-5}$). Однако из-за нестабильности показателя сходимости самого метода Симпсона, уточнение Эйткена иногда дает ошибку больше, чем сам метод (например, при $N=128$).
    
    Тем не менее, при максимальном числе разбиений ($N=2048$):
    *   Ошибка Симпсона: $\approx 1.17 \cdot 10^{-7}$
    *   Ошибка Эйткена: $\approx 8.01 \cdot 10^{-8}$

### График сходимости

![График сходимости](/HW6/Task1/imgs/grapics.png)

**Итоговый ответ:**  
При $N=2048$ получено значение интеграла **0.4600437** с абсолютной погрешностью порядка **$10^{-7}$**.

**Выводы:**
1. Из-за негладкости подынтегральной функции классический теоретический порядок O(h^4) для метода Симпсона снижается и в численных экспериментах примерно $p_{eff} \approx 3$.

2. Процесс Эйткена часто улучшает точность (иногда на несколько порядков), но его эффективность зависит от поведения ошибок при изменении шага - он не даёт гарантированного улучшения на всех наборах разбиений.

3. При больших N наблюдается граница, обусловленная машинной погрешностью - дальнейшее увеличение N не приведёт к заметному снижению абсолютной ошибки, так как шаг становится очень маленьким, все вычисления начинают работать в зоне, где разности практически не отличаются в пределах машинной точности - часть значащих цифр просто теряется (суммируем сотни множество значений вида $f(x_i)$ которые близки друг к другу).