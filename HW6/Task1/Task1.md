# Задача 6

> Все расчеты находятся в файле [Task1.ipynb](/HW6/Task1/Task1.ipynb)

## Численное интегрирование методом Симпсона с уточнением по Эйткену

### Постановка задачи

Вычисляется значение интеграла:

$$ I = \int_{0}^{\pi} \left| \cos(\sin(x)) - \frac{3}{4} \right| dx $$

Для вычислений будет использовать **составной метод Симпсона** с автоматическим выбором шага (по правилу Рунге) и последующим уточнением результата с помощью **процесса Эйткена**

#### Составной метод Симпсона (`simpson_method`)

Функция реализует классическую формулу составного метода Симпсона (метода парабол). Отрезок $[a, b]$ разбивается на $n$ частей с шагом $h = \frac{b-a}{n}$.

**Алгоритм работы функции:**
1.  Вычисляется шаг `h`.
2.  Суммируются значения функции на краях отрезка (`integral`).
3.  В цикле суммируются значения во внутренних узлах:
    *   Для **нечетных** индексов ($x_1, x_3, \dots$) используется коэффициент **4**.
    *   Для **четных** индексов ($x_2, x_4, \dots$) используется коэффициент **2**.
4.  Результат умножается на $h/3$.

**Код:**
```python
def simpson_method(f, a, b, n):
    h = (b - a) / n
    integral = f(a) + f(b)
    
    sum_odd = 0
    for i in range(1, n, 2):      # Нечетные узлы
        sum_odd += f(a + i * h)
        
    sum_even = 0
    for i in range(2, n, 2):      # Четные узлы
        sum_even += f(a + i * h)
        
    integral = (h / 3) * (integral + 4 * sum_odd + 2 * sum_even)
    return integral
```

#### Процесс Эйткена (`aitken_process`)

Этот метод используется для экстраполяции последовательности приближенных значений к точному решению. Он позволяет повысить точность результата, используя информацию о скорости сходимости метода.

В функцию передаются три значения интеграла, вычисленные с разными шагами:
*   `I_h`: Значение интеграла с текущим шагом $h$ (самое точное, $N$ разбиений).
*   `I_2h`: Значение с шагом $2h$ ($N/2$ разбиений).
*   `I_4h`: Значение с шагом $4h$ ($N/4$ разбиений).

**Используемая формула:**

$$\tilde I = I_h - \frac{(I_{2h} - I_h)^2}{I_{4h} - 2I_{2h} + I_h} $$

**Код:**
```python
def aitken_process(I_h, I_2h, I_4h):
    numerator = (I_2h - I_h) ** 2
    denominator = I_4h - 2 * I_2h + I_h
    return I_h - (numerator / denominator)
```

#### Основная логика

Сначала задаются границы интегрирования и количество разбиений.

Сделать теоритическую оценку затруднительно, так как есть модуль, что делает функцию негладкой в некоторых точках (где функция меняет знак).
Поэтому используется автоматический выбор шага для достижения точности по правилу Рунге.

Основная программа выполняет вычисления итеративно:

1.  **Инициализация**:
    *   Задаются границы интегрирования `a=0`, `b=pi`.
    *   Начальное число разбиений `n=2`.
    *   Создается список `history` для хранения результатов всех итераций.

2.  **Цикл удвоения (`while True`)**:
    *   Число разбиений `n` удваивается на каждой итерации.
    *   Вычисляется новое значение интеграла `current_val`.
    *   **Оценка погрешности (Правило Рунге)**:
        Так как метод Симпсона имеет 4-й порядок точности, погрешность оценивается как:
        
        $$R \approx \frac{|I_{current} - I_{prev}|}{2^4 - 1} = \frac{|I_{current} - I_{prev}|}{15}$$
        
    *   Результат выводится в таблицу.

3.  **Условие остановки**:
    Цикл прерывается, если выполняются **два** условия:
    1.  Оценка погрешности меньше заданной точности (`runge_error < epsilon`).
    2.  В истории накоплено минимум 3 значения (`len(history) >= 3`), что необходимо для работы процесса Эйткена.

4.  **Финальное уточнение**:
    После выхода из цикла программа берет последние три вычисленных значения из `history` и применяет функцию `aitken_process` для получения еще более точного результата.

Полученные результаты:

- Истинное значение интеграла: $I_{eq} = 0.460043630499834$
- Значение интеграла (м. Симпсона, n = 32): $I = 0.460093083$
- Уточненное значение интеграла процессом Эйткена: $\tilde I = 0.4600641958$
